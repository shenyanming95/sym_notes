# 1.理论

## 1.1.内存条

内存，也叫DRAM，即动态随机存储器。本质上它就是下图所示的条型组件：

![](https://static001.geekbang.org/resource/image/0d/8e/0d0d85383416f2f8841aeebe7021a88e.jpg?wh=3541*1553)

在 PCB 板上有内存颗粒芯片，主要是用来存放数据的。SPD 芯片用于存放内存自身的容量、频率、厂商等信息。还有最显眼的金手指，用于连接数据总线和地址总线，电源等。

内存储存颗粒芯片中的存储单元是由电容和相关元件做成的，电容存储电荷的多、少代表数字信号 0 和 1。而随着时间的流逝，电容存在漏电现象，这导致电荷不足，就会让存储单元的数据出错，所以 DRAM 需要周期性刷新，以保持电荷状态。因此内存需要不断地供电。

**逻辑上我们只需要把内存看成一个巨大的字节数组就可以，而内存地址就是这个数组的下标**。

## 1.2.局部性原理

局部性原理：在程序的执行过程中，数据和指令的访问往往具有局部集中的特点。主要包括以下两个方面：

1. 时间局部性（Temporal Locality）：时间局部性指的是程序在一段时间内对某个数据或指令的多次访问。当程序执行一条指令或者访问一个数据时，很可能在近期的某个时间点再次访问同样的指令或数据。这是因为在程序中，往往会有循环结构、重复的子程序调用等，导致某些数据和指令在短时间内被多次使用。
2. 空间局部性（Spatial Locality）：空间局部性指的是程序在一段时间内访问的数据或指令在空间上彼此相邻。当程序访问某个数据或指令时，它很可能会在附近的内存位置访问其他相关的数据或指令。这是因为程序的数据和指令通常以连续的块或者相邻的存储位置进行存储，因此对一个数据或指令的访问往往会引起对附近数据或指令的访问。

通过这个原理可得到一个结论：无论一个进程占用的内存资源有多大，在任一时刻，它需要的物理内存都是很少的

# 2.虚拟内存

## 2.1.分段式

## 2.2.分页式

# 3.内存布局

当程序保存在磁盘时，它的每一个单元结构被称为Section；当程序被加载到内存时，它的每一个单元结构被称为Segment。Segment会将具有相同权限属性的Section集映射到一起，为它们分配一块内存空间，因此往往多个Section对应一个Segment，例如：

- `.text`、`.rodata`等只读的Section，会映射到内存的「只读/执行」权限的Segment里；
- `.data`、`.bss`等可读写的Section，会映射到内存的「读写」权限的Segment里；
- `.symtab`、`.strtab`等磁盘二进制的一些辅助信息的Section，不会在内存中映射；

![](https://static001.geekbang.org/resource/image/bc/c9/bca1533a0af7ee8476yy12f4b04083c9.jpg?wh=2284x1319)

## 3.1.逻辑布局

![](https://static001.geekbang.org/resource/image/fc/c0/fcb6231d9cc3841643e4b84462e5b3c0.jpg?wh=2284x1980)

CPU运行一个程序，需要将存放在磁盘的进程文件载入内存，因此就会有进程的内存布局：

- 代码段：存储程序的机器码
- 数据段：在程序源代码中，对于有初值的变量，它的初始值会存放在程序的二进制文件。那么在加载这个程序的时候，这些数据也会被装载到内存中，即程序的数据段。因此，数据段存放的是程序中已经初始化且不为0的全局变量和静态变量
- BSS段：已经初始化的全局变量和静态变量会存放在「数据段 」，而对于未初始化的，编译器知道默认值都是0，所以不需要将其保存到二进制文件，进而就不需要加载到「数据段」，只需要记录它们的大小，此时就会存储到BSS段（全称是 Block Started by Symbol，也被记为 Better Save Space）
- 栈/堆：「数据段」和「BSS段」都会存储变量，主要是全局变量和静态变量。但在程序运行期间，还需要记录临时变量和运行时产生的变量，这些会被存储在「堆空间」和「栈空间」

以上是一个进程运行的基本内存布局，现代应用程序还会包含其它区域，主要是：

1. 存放加载的共享库的内存空间：如果一个进程依赖共享库，那对应的，该共享库的代码段、数据段、BSS 段也需要被加载到这个进程的地址空间中
2. 共享内存段：我们可以通过系统调用映射一块匿名区域作为共享内存，用来进行进程间通信
3. 内存映射文件：我们也可以将磁盘的文件映射到内存中，用来进行文件编辑或者是类似共享内存的方式进行进程通信

## 3.2.IA-32位

32位机器上，每个进程具有4GB的寻址能力，Linux默认将高地址的1GB空间分配给内核，剩余的低3GB是用户可以使用的用户空间

![](https://static001.geekbang.org/resource/image/61/b2/61ee74faa861797b34397ed837a027b2.jpg?wh=2284x1808)

## 3.3.Intel-64位

目前，Intel 64 处理器往往支持 48 位的虚拟地址，则寻址空间是 2^48，即 256TB。将低 128T 的空间划分为用户空间，高 128T 划分为内核空间：

![](https://static001.geekbang.org/resource/image/12/1c/1258dabe44e33c66c0f423d8d24a8f1c.jpg?wh=2284x1578)

# 4.栈

堆的空间有一个向下的箭头，标明栈地址空间的增长方向（栈地址是向低地址方向增长），每次进程再向内核申请新的栈地址时，其地址值是减少的。栈的指针叫做“Stack pointer”

# 5.堆

堆的空间有一个向上的箭头，标明堆地址空间的增长方向，每次进程再向内核申请新的堆地址时，其地址值是增大的。堆的指针叫做“Program break”

## 5.1.申请堆空间

不管是 32 位系统还是 64 位系统，内核都会维护一个变量 brk，指向堆的顶部，所以，brk 的位置实际上就决定了堆的大小。Linux系统提供了两个重要的系统调用来修改堆的大小，分别是sbrk和mmap。

【sbrk】

```c
#include <unistd.h>
void* sbrk(intptr_t incr);
```

sbrk函数通过给内核的brk变量增加`incr`以改变堆的大小，当`incr`为正数，堆增大；当`incr`为负数，堆减小。函数执行成功，返回brk变量的旧值；执行失败，返回-1，同时将errno设置为ENOMEM。

在C语言的运行库里，提供了 malloc() 和 free() 实现堆内存的分配和回收。但其实，C语言的运行库使用sbrk()向操作系统申请一块大内存，再由  malloc() 完成再分配。

【mmap】

```c
#include <unistd.h>
#include <sys/mman.h>
/**
 * addr:   该内存区域的起始地址
 * length: 该内存区域的长度
 * prot:   该内存区域的访问权限
 * flags:  该内存区域的类型
 * fd:     文件描述符
 * offset: 文件内的偏移量
 */
void* mmap(void* addr, size_t length, int prot, int flags, int fd, off_t offset);
```

mmap的功能随之 prot、flags和fd这三个参数的不同，可以用于创建共享内存，可以创建磁盘文件映射区域，还可以用来申请堆内存。

- prot的值可以是以下四个常量的组合：
  - PROT_EXEC，表示这块内存区域有可执行权限，意味着这部分内存可以看成是代码段，它里面存储的往往是 CPU 可以执行的机器码；
  - PROT_READ，表示这块内存区域可读；
  - PROT_WRITE，表示这块内存区域可写；
  - PROT_NONE，表示这块内存区域的页面不能被访问；
- flags的值常量多（可以通过man mmap查看），以下是最重要的四种可取值常量：
  - MAP_SHARED，创建一个共享映射的区域，多个进程可以通过共享映射的方式，来共享同一个文件。这样一个进程对该文件的修改，其他进程也可以观察到，可以实现了数据的通讯；
  - MAP_PRIVATE，创建一个私有的映射区域，多个进程可以使用私有映射的方式，来映射同一个文件。但是，当一个进程对文件进行修改时，操作系统就会为它创建一个独立的副本，这样它对文件的修改，其他进程就看不到了，从而达到映射区域私有的目的；
  - MAP_ANONYMOUS，创建一个**匿名映射**，也就是没有关联文件。使用这个选项时，fd 参数必须为空。通常可以使用私有匿名映射来进行堆内存的分配。
  - MAP_FIXED，一般来说，addr 参数只是建议操作系统尽量以 addr 为起始地址进行内存映射，但如果操作系统判断 addr 作为起始地址不能满足长度或者权限要求时，就会另外再找其他适合的区域进行映射。如果 flags 的值取是 MAP_FIXED 的话，就不再把 addr 看成是建议了，而是将其视为强制要求。如果不能成功映射，就会返回空指针；
- fd的值只有两种类型：
  - 不为0，mmap映射的内存区域将会和文件关联；
  - 为0，没有对应的相关文件，此时就是匿名映射，flags 的取值必须为 MAP_ANONYMOUS；

![](https://static001.geekbang.org/resource/image/98/93/98fcb5aa607b8be9ffa037e9f7eea593.jpg?wh=2284x1285)
