# 1.分库分表概念

分库分表其实是两个概念：分库和分表，又可以细化为：垂直拆分和水平拆分。所以分库分表其实是4个概念：

1. 垂直分库
2. 水平分库
3. 垂直分表
4. 水平分表

分库分表就是为了解决由于数据量过大导致数据库性能降低的问题，将原来独立的数据库拆分成若干数据库组成，将数据大表拆分成若干数据表组成，使得单一数据库、单一数据表的数据量变小，从而达到提升数据库性能的目的

分库分表一定是为了解决**高并发、数据量大**两个问题的，传统关系型数据库，一个数据库最多支撑到并发 2000，一张表数据量几百万的时候，性能就会很差，sql就跑得很慢。但随着公司业务的发展，数据量是绝对会越来越大的，最终数据库所能承载的数据量、数据处理能力都将遭遇瓶颈，所以我们需要【拆】

## 1.1.垂直分表

定义：**将一个大表按照字段分成若干张表，每张表存储原来大表的一部分字段**。

按照以下原则进行垂直分表：

1. 把不常用的字段单独放在一张表
2. 把txt、blob等大字段拆分出来放在附表
3. 经常组合查询的字段放在一张表

## 1.4.垂直分库

[垂直分表](#1.1.垂直分表)虽然能得到一定性能的提升，但是拆分后的表仍然处于同一个库（确切地说是位于同一个服务器上），这其实还是竞争同一个物理机的CPU、内存、网络IO和磁盘。

定义：**按照业务将表进行分类，分布到不同的数据库上，每个库单独放在一个服务器上，它的核心理念是专库专用**

## 1.5.水平分库

用了垂直分表和垂直分库，可以将一张大表也拆分成若干业务表，再将业务表放在不同数据库上。但是，随着业务的发展，数据量剧增，每个业务表自身也会达到一个量级，这时候就需要对业务表做水平分库

定义：**把同一个表的数据按照一定规则拆分到不同的数据库中，每个数据库放在独立的服务器上(每个库中的业务表结构都一样，只不过数据不同)**

## 1.6.水平分表

水平分库可以解决大部分的问题，但是水平分库有个缺点，就是需要增加数据库实例，这对运维压力很大，所以同时会配合使用水平分表。

水平分表：**在同一个数据库内，把同一张表的数据按照一定规则拆分到多个表中，每个表的结构一样，但是数据不同，其实和水平分库类似，只不过一个是划分库，一个只划分表**

## 1.7.总结

总的来说，垂直划分就是根据结构来划分，水平划分就是根据业务数据来划分：

- 垂直分表是拆分表字段将大表划分为各个小表，垂直分库是将一个库内的表拆分到单独数据库上
- 水平分表是将一张表的数据划分到不同表存储，水平分库是将一张表的数据分到不同数据库存储

一般来说，在系统设计阶段就应该根据业务耦合松紧来确定**垂直分库**和**垂直分表**方案（优先完成），在数据量以及访问压力不大的情况，先考虑缓存、读写分离和索引优化等方案。真到了业务数据量剧增，且持续增长，再来考虑水平分库和水平分表。

千万不要为了分库分表而分库分表，技术有利就有弊，分库分表后需要解决的额外挑战：

1. **事务一致性问题**：由于数据分布在不同库甚至不同库，就必须考虑分布式事务问题；
2. **跨节点关联查询**：原先单表或者单库，如果要做多表关联查询，通过join连接查询便可以解决。但如果分库分表后，一次查询是绝对没办法做到的，需要在多库中多次查询后再拼装；
3. **跨节点分页、排序函数**：分库分表后，limit分页、order by 排序等问题，就变得复杂，需要先在不同节点的分片节点将数据进行排序并发回，然后将不同分片发回的结果集进行汇总再排序；
4. **主键避重**：分录分表后单表的自增主键就无法使用，需要引入全局主键，避免跨库主键重复问题；
5. **公共表**：实际开发中，对于参数表、数据字典等公共表，都是每个库都需要使用的，所以分库分表后，对公共表数据的处理，需要同步到各个分库上。

# 2.sharding-jdbc简介

sharding-jdbc是当当网研发的开源分布式数据库中间件，从3.0开始sharding-jdbc被包含在Sharding-Sphere中，并在2020年4月16日从[Apache孵化器](http://incubator.apache.org/projects/shardingsphere.html)毕业，成为Apache顶级项目。

sharding-jdbc是Sharding-Sphere的模块之一，定位为轻量级Java框架，在Java的JDBC层提供的额外服务。 它使用客户端直连数据库，以jar包形式提供服务，无需额外部署和依赖，可理解为增强版的JDBC驱动，完全兼容JDBC和各种ORM框架；sharding-jdbc的核心功能为**数据分片**和**读写分离**。通过sharding-jdbc可以**透明的**使用jdbc访问已经分库分表、读写分离的多个数据源，而不用关系数据库的数量以及数据如何分布。

<img src="./images/sharding-jdbc架构图.png" style="zoom:60%;" />

## 2.1.SQL

### 2.1.1.逻辑表

水平拆分的数据库（或数据表）的相同逻辑和数据结构表的总称，例如：订单数据根据主键拆分成10张表，分别是t_order_0 ~ t_order_9（这是[实际表](#2.1.2.真实表)名），则这些表的逻辑表名就为t_order

### 2.1.2.真实表

在分片的数据库中**真实存在**的物理表，就是上面[逻辑表](#2.1.1.逻辑表)举例的t_order_0 ~ t_order_9

### 2.1.3.数据节点

数据分片的最小单元，即数据源 + 数据表，例如：db1.t_order_o，表示名称为db1的数据源（对应一个数据库）的t_order_0真实表

### 2.1.4.绑定表

指分片规则一致的主表和子表。例如：`t_order`表和`t_order_item`表，均按照`order_id`分片，则此两张表互为绑定表关系。绑定表之间的多表关联查询不会出现笛卡尔积关联，关联查询效率将大大提升

### 2.1.5.广播表

指所有的分片数据源中都存在的表，表结构和表中的数据在每个数据库中均完全一致。适用于数据量不大且需要与海量数据的表进行关联查询的场景，例如：字典表。

## 2.2.分片

### 2.2.1.分片键

用于分片的**数据库字段**，是将数据库（或数据表）水平拆分的关键字段。例如：将t_order表中的主键的尾数对2取模分片，奇数的分到数据源db1，偶数的分到数据源db2，那么t_order表的主键就称为分片键。SQL中如果无分片字段，将执行全路由，性能较差。 除了对单分片字段的支持，ShardingSphere也支持根据多个字段进行分片。

### 2.2.2.分片算法

通过分片算法将数据分片，支持通过`=`、`>=`、`<=`、`>`、`<`、`BETWEEN`和`IN`分片。分片算法需要开发者自行实现，可实现的灵活度非常高。sharding-jdbc并未提供内置的分片算法，只是提供接口由开发者自行实现分片算法，当前版本提供4种：

- 精确分片算法：

对应**PreciseShardingAlgorithm**，用于处理使用单一键作为分片键的=与IN进行分片的场景，需要配合**StandardShardingStrategy**使用

- 范围分片算法

对应**RangeShardingAlgorithm**，用于处理使用单一键作为分片键的BETWEEN AND、>、<、>=、<=进行分片的场景，需要配合**StandardShardingStrategy**使用。

- 复合分片算法

对应**ComplexKeysShardingAlgorithm**，用于处理使用多键作为分片键进行分片的场景，包含多个分片键的逻辑较复杂，需要开发者自行处理其中的复杂度，配合**ComplexShardingStrategy**使用

- Hint分片算法

对应**HintShardingAlgorithm**，用于处理使用Hint行分片的场景，需要配合**HintShardingStrategy**使用。

### 2.2.3.分片策略

包含[分片键](#2.2.1.分片键)和[分片算法](#2.2.2.分片算法)，由于分片算法的独立性，将其独立抽离，真正可用于分片操作的是分片键 + 分片算法，即分片策略 = 分片算法 + 分片键，它才是真正用于分片的实现。目前提供5种分片策略

- 标准分片策略

对应**StandardShardingStrategy**，提供对SQL语句中的=, >, <, >=, <=, IN和BETWEEN AND的分片操作支持。StandardShardingStrategy只支持单分片键，提供**PreciseShardingAlgorithm（精确分片算法）**和**RangeShardingAlgorithm（范围分片算法）**两个分片算法，其中PreciseShardingAlgorithm是必选的，用于处理=和IN的分片。RangeShardingAlgorithm是可选的，用于处理BETWEEN AND, >, <, >=, <=分片。如果不配置RangeShardingAlgorithm，SQL中的BETWEEN AND将按照全库路由处理

- 复合分片策略

对应**ComplexShardingStrategy**。提供对SQL语句中的=, >, <, >=, <=, IN和BETWEEN AND的分片操作支持。ComplexShardingStrategy支持多分片键，由于多分片键之间的关系复杂，因此并未进行过多的封装，而是直接将分片键值组合以及分片操作符透传至分片算法，完全由应用开发者实现，提供最大的灵活度

- 行表达式分片策略

对应**InlineShardingStrategy**。使用Groovy的表达式，提供对SQL语句中的=和IN的分片操作支持，只支持**单分片键**。对于简单的分片算法，可以通过简单的配置使用，从而避免繁琐的Java代码开发，如: `t_user_$->{u_id % 8}` 表示t_user表根据u_id模8，而分成8张表，表名称为`t_user_0`到`t_user_7`。

- Hint分片策略

对应**HintShardingStrategy**。通过Hint指定分片值而非从SQL中提取分片值的方式进行分片的策略。

- 不分片策略

对应NoneShardingStrategy。不分片的策略。

### 2.2.4.SQL Hint

对于分片字段非SQL决定，而由其他外置条件决定的场景，可使用SQL Hint灵活的注入分片字段。例：内部系统，按照员工登录主键分库，而数据库中并无此字段。SQL Hint支持通过Java API和SQL注释(待实现)两种方式使用。

## 2.3.配置

### 2.3.1.分片规则

分片规则配置的总入口。包含数据源配置、表配置、绑定表配置以及读写分离配置等

### 2.3.2.数据源配置

真实数据源列表。

### 2.3.3.表配置

逻辑表名称、数据节点与分表规则的配置。

### 2.3.4.数据节点配置

用于配置[逻辑表](#2.1.1.逻辑表)与[真实表](#2.1.2.真实表)的映射关系。可分为均匀分布和自定义分布两种形式。

- 均匀分布

指数据表在每个数据源内呈现均匀分布的态势，例如：

```text
db0
  ├── t_order0 
  └── t_order1 
db1
  ├── t_order0 
  └── t_order1
```

对应的数据节点配置：

```sql
db0.t_order0, db0.t_order1, db1.t_order0, db1.t_order1
```

- 自定义分布

指数据表呈现有特定规则的分布，例如：

```text
db0
  ├── t_order0 
  └── t_order1 
db1
  ├── t_order2
  ├── t_order3
  └── t_order4
```

对应的数据节点配置：

```sql
db0.t_order0, db0.t_order1, db1.t_order2, db1.t_order3, db1.t_order4
```

### 2.3.5.分片策略配置

对于分片策略存有数据源分片策略和表分片策略两种维度。

- 数据源分片策略

对应于**DatabaseShardingStrategy**。用于配置数据被分配的目标数据源。

- 表分片策略

对应于**TableShardingStrategy**。用于配置数据被分配的目标表，该目标表存在与该数据的目标数据源内。故表分片策略是依赖与数据源分片策略的结果的。

### 2.3.6.自增主键生成策略

通过在客户端生成自增主键替换以数据库原生自增主键的方式，做到分布式主键无重复。

# 3.sharding-jdbc执行流程

sharding-jdbc一个完整的执行流程：`SQL解析 => 执行器优化 => SQL路由 => SQL改写 => SQL执行 => 结果归并`

<img src="./images/sharding-jdbc执行流程.png" style="zoom:67%;" />

## 3.1.SQL解析

解析过程分为**词法解析**和**语法解析**。 词法解析器用于将SQL拆解为不可再分的原子符号，称为Token。并根据不同数据库方言所提供的字典，将其归类为关键字，表达式，字面量和操作符。 再使用语法解析器将SQL转换为抽象语法树。例如有如下SQL：

```sql
SELECT id, name FROM t_user WHERE status = 'ACTIVE' AND age > 18
```

解析之后的为抽象语法树见下图。

<img src="./images/抽象语法树例子.png" style="zoom:80%;" />

抽象语法树中的关键字的Token用绿色表示，变量的Token用红色表示，灰色表示需要进一步拆分。其中红色的变量就是需要被改写的，要结合[分片策略](#2.3.5.分片策略)进行SQL改写。

通过对抽象语法树的遍历去提炼分片所需的上下文，并标记有可能需要SQL改写的位置。 供分片使用的解析上下文包含查询选择项（Select Items）、表信息（Table）、分片条件（Sharding Condition）、自增主键信息（Auto increment Primary Key）、排序信息（Order By）、分组信息（Group By）以及分页信息（Limit、Rownum、Top）。 SQL的一次解析过程是不可逆的，一个个Token的按SQL原本的顺序依次进行解析，性能很高。 考虑到各种数据库SQL方言的异同，在解析模块提供了各类数据库的SQL方言字典

## 3.2.SQL路由

SQL路由就是把针对[逻辑表](#2.1.1.逻辑表)的数据操作映射到对[数据节点](#2.1.3.数据节点)操作的过程。

## 3.3.SQL改写



## 3.4.SQL执行



## 3.5.结果归并



# 4.sharding-jdbc运用配置



# 5.sharding-jdbc源码分析

