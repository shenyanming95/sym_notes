程序=数据结构+算法！

# 1.数组

## 1.1.稀疏数组

稀疏数组，即sparse array。怎么理解稀疏数组？可以看这样一个场景：有如下一个五子棋盘，如果要保存当前棋局，很自然地会想到用二维数组去保存， 

<img src="./images/稀疏数组_棋盘.png" style="zoom:50%;" />

<img src="./images/稀疏数组_棋盘_二维数组保存.png" style="zoom:50%;" />

但是这样会有一个严重的问题，内存浪费严重，而且棋盘数据越少，浪费就越严重。当前只有2个棋子需要记录，但却开辟了一整块棋盘n*m的内存空间，保存无意义的0，在这种场景下，应该用稀疏数组替换掉二维数组。

 稀疏数组的做法是：

1. 记录原二维数组几行几列，有多少个值

2. 把有值的行列及其对应值记录到小规模数组上(即把原数组的数据压缩起来)

<img src="./images/稀疏数组_转换前.png" style="zoom:50%;" />

假设有如上的数组，它一共有6行7列，并且有8个非零值，要将其转换成稀疏数组可以这样操作：因为有8个非零值，说明就有8个行列要记录，所以新生成的稀疏数组至少需要8行；加上又要统计原数组的总行列数，又要多出1行，因此待转换的稀疏数组就要有9行。而稀疏数组只要记录元素组的行、列和值，所以需要3列。最终，上面数组转换的稀疏数组就是下面这个样子：

<img src="./images/稀疏数组_转换后.png" style="zoom:50%;" />

第一行：表示原数组有6行7列，有8个非零值

第二行：表示原数组的第1行的第4列（列数以0开始计数），值为22

 ...

 以此类推

# 2.线性表

# 3.栈

# 4.队列

队列最突出的特点就是FIFO（先进先出）原则，实现一个队列有两种方式：

1. 底层使用数组存储元素，称为顺式队列；

2. 底层使用链表存储元素，称为链式队列；

## 4.1.顺式队列

要实现一个顺式队列，需要两个指标：front和rear，一个表示队首，一个表示队尾。在逻辑上，必须控制元素入队被rear控制，元素出队被front控制！实际上，如果简单使用数组实现队列，会有个问题就是“假溢出”，即实际上有部分元素已经出队，但是由于rear指针递增，在临近数组长度时，就不能再接收新元素。因此一般会做成顺式循环队列

## 4.2.链式队列

# 5.哈希表

# 6.树

## 6.1.二叉查找树

二叉查找树，又称二叉排序树，是一种动态查找表，具有这些性质：

<img src="./images/二叉查找树.png" style="zoom:75%;" />

1. 若它的左子树不为空，则左子树上的所有节点的值都小于它的根结点；

2. 若它的右子树不为空，则右子树上的所有节点的值都大于它的根结点；

3. 其它的左右子树也分别为二叉查找树；

4. 二叉查找树是动态查找表，在查找的过程中可见添加和删除相应的元素，在这些操作中需要保持二叉查找树的以上性质

## 6.2.平衡二叉树

平衡二叉树也称为AVL树，具有如下的性质：

<img src="./images/平衡二叉树.png" style="zoom:70%;" />

1. 要么空树，要么其根结点左右子树的深度之差的绝对值不超过1；

2. 其左右子树也是平衡二叉树；

3. 二叉树节点的平衡因子定义为该节点的左子树的深度减去右子树的深度。则平衡二叉树的所有节点的平衡因子只可能是-1,0,1

## 6.3.红黑树

红黑树是一种自平衡二叉树，在平衡二叉树的基础上每个节点又增加了一个颜色的属性，节点的颜色只能是红色或黑色。具有如下的性质：

<img src="./images/红黑树.png" style="zoom:67%;" />

1. 根结点只能是黑色；

2. 每个结点非红即黑，若一个结点为红色，则它的左右结点一定为黑色；

3. 每个叶子结点（即树尾端null指针或null节点）都是黑色；

4. 任意结点到叶子结点的nil指针的每条路径都包含相同的黑色结点

## 6.4.B树

B树和[B+树](#6.5.B+树)，都是为磁盘为磁盘或其它存储设备而设计的一种平衡多路查找树。相对于二叉树，B树每个内节点有多个分支；与红黑树相比，在相同的节点的情况下，一棵B/B+树的高度远远小于红黑树的高度。B/B+树上操作的时间通常由存储磁盘的时间和CPU计算时间这两个部分构成，CPU计算时间可以忽略不计，所以B树的操作效率取决于访问磁盘的次数，关键字总数相同的情况下B树的高度越小，磁盘I/O所花的时间越少。

![](./images/B树.png)

一颗m阶的B tree有如下特性：

1. 每个结点最多 m 个子结点；

2. 除了根结点和叶子结点外，每个结点最少有 m/2(向上取整)个子结点；

3. 如果根结点不是叶子结点，那根结点至少包含两个子结点；

4. 所有的叶子结点都位于同一层；

5. 每个结点都包含 k 个元素(关键字)，这里 m/2≤k。

6. 每个节点中的元素(关键字)从小到大排列。

7. 每个元素(关键字)字左结点的值，都小于或等于该元素(关键字)；右结点的值都大于或等于该元素(关键字)。

## 6.5.B+树

B+树是[B树](#6.4.B树)的一种变形，它与B树的差别在于：

1. 有n棵子树的节点含有n个关键字；

2. 所有的叶子节点包含了全部关键字的信息，及指向这些关键字记录的指针，且叶子节点本身按关键字大小自小到大顺序链接；

3. 所有非终端节点可以看成是索引部分，节点中仅含有其子树（根节点）中最大（或最小）关键字，所有B+树更像一个索引顺序表；

4. 对B+树进行查找运算，一是从最小关键字起进行顺序查找，二是从根节点开始，进行随机查找。

![](./images/B+树.png)

## 6.6.字典树

字典树，也称trid树。是一种以树形结构保存大量字符串。以便于字符串的统计和查找，经常被搜索引擎系统用于文本词频统计。它的优点是：利用字符串的公共前缀来节约存储空间，最大限度地减少无谓的字符串比较，查询效率比哈希表高。有以下特点：

<img src="./images/字典树.png" style="zoom:67%;" />

1. 根节点为空；

2. 除根节点外，每个节点包含一个字符；

3. 根节点到某一节点，路径上经过的字符连接起来，为该节点对应的字符串；

4. 每个字符串在建立字典树的过程中都要加上一个区分的结束符，避免某个短字符串正好是某个长字符串的前缀而淹没

# 7.图

