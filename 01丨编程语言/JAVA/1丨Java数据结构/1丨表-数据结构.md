# `程序=数据结构+算法！`

# 1.【基础概念】

数据结构是计算机存储、组织数据的方式，即将数据通过一定规则，或者一些巧妙地设计存储数据，然后可以运用这样设计的优势，使其符合某一些特定的场景，对数据进行再利用！！

## 1.1.逻辑结构

数据的逻辑结构，指的是数据之间的逻辑关系

![](./images/概念-数据逻辑结构.png)

## 1.2.物理结构

物理结构，指的是数据在物理存储空间上选择集中存放还是分散存放，即常说的顺式存储和链式存储。数据进行集中存储有利于后期对数据进行遍历操作，而分散存储更有利于后期增加或删除数据。如果需要对数据进行大量的检索（遍历），就选择集中存储；反之，若需要对数据做进一步更新（增加或删除），则选择分散存储！

![](./images/概念-数据物理结构.gif)

# 2.【数组】

数组是一种顺序存储的线性表，所有元素的内存地址都是连续的。

<img src="./images/基本数组.png" style="zoom:67%;" />

## 2.1.稀疏数组

稀疏数组，即sparse array。怎么理解稀疏数组？可以看这样一个场景：有如下一个五子棋盘，如果要保存当前棋局，很自然地会想到用二维数组去保存， 

<img src="./images/稀疏数组_棋盘.png" style="zoom:50%;" />

但是这样会有一个严重的问题，内存浪费严重，而且棋盘数据越少，浪费就越严重。当前只有2个棋子需要记录，但却开辟了一整块棋盘n*m的内存空间，保存无意义的0，在这种场景下，应该用稀疏数组替换掉二维数组。

 稀疏数组的做法是：

1. 记录原二维数组几行几列，有多少个值
2. 把有值的行列及其对应值记录到小规模数组上(即把原数组的数据压缩起来)

<img src="./images/稀疏数组_转换前.png" style="zoom:50%;" />

假设有如上的数组，它一共有6行7列，并且有8个非零值，要将其转换成稀疏数组可以这样操作：因为有8个非零值，说明就有8个行列要记录，所以新生成的稀疏数组至少需要8行；加上又要统计原数组的总行列数，又要多出1行，因此待转换的稀疏数组就要有9行。而稀疏数组只要记录元素组的行、列和值，所以需要3列。最终，上面数组转换的稀疏数组就是下面这个样子：

<img src="./images/稀疏数组_转换后.png" style="zoom:50%;" />

第一行：表示原数组有6行7列，有8个非零值

第二行：表示原数组的第1行的第4列（列数以0开始计数），值为22

 ... 以此类推

## 2.2.动态数组

大部分编程语言的数组都是不可扩容的，但是，在数据容量不足时，通过创建一个容量 * 2的新数组，将旧数组的数据复制到新数组中，就可以实现数组的动态扩容，这种数组就称为动态数组。

# 3.【链表】

链表是一种链式存储的线性表，所有元素的内存地址不一定是连续的。链表中每个数据的存储都会分为2个部分：数据域和指针域：

- 数据域：数据元素本身
- 指针域：指向直接前驱/后继元素的指针

## 3.1.单向链表

单向链表意味着只能从A→B，但B不能→A，单链表有一个重要知识点：单链表反转，可以通过头插法来实现

![](./images/单向链表.png)

## 3.2.双向链表

![](./images/双向链表.png)

## 3.3.循环链表

如果单向链表将最后一个节点Node的next指针指向头节点，那么这种链表就称为单向循环链表：

![](./images/单向循环链表.png)

同理，如果双向链表的next和prev指针也头节点，那么这种链表就称为双向循环链表：
<img src="./images/双向循环链表.png" style="zoom:80%;" />

# 4.【栈】

栈是一种特殊的线性表，只能在一端进行操作，栈的开口端被称为栈顶，封口端被称为栈底。往栈中添加元素的操作，叫做push（入栈）；从栈中移除元素的操作，一般叫做pop（出栈，只能移除栈顶元素），栈是一种“先进后出”原则的数据结构！

![](./images/栈.png)

## 4.1.顺序栈

顺序栈，就是基于数组实现的栈存储结构。在数组中会设定一个指向栈顶元素的指针（一般命名为 top），top 初始值为 -1，表示栈中没有存储任何数据元素，即"空栈"。如果元素进栈，则 top ++；反之，如果数据元素出栈，top --

**入栈过程：**

申请一块数组，定义一个指针top，top在物理结构上表示数组的下标，在逻辑结构上表示栈顶元素（即top的值就是栈顶元素在数组的下标）top的初始值为-1，表示这是一个空栈。当数据元素`1`入栈后，top++，其值变为0，同时栈顶元素就变为1...以此类推，当`1,2,3,4`都入栈后，top就会变为3，表示栈顶元素位于数组index=3的位置。

![](./images/顺序栈-入栈过程.png)

**出栈过程**

出栈的时候，只允许从指针top开始弹出元素，一开始top=3表示栈顶元素位于底层数组index=3的位置，元素值为`4`，将其弹出后，top--变为2，现在栈顶元素就位于底层数组index=2的位置：

![](./images/顺序栈-出栈过程.gif)

## 4.2.链栈

链栈，就是用链表实现的栈。对于链表，一般会定义一个头节点head用来指向栈顶元素，即链表的首个元素。同时，链表的头部作为栈顶，尾部作为栈底：

![](./images/链栈-存储结构.gif)

数据元素在入栈时，需要在栈顶添加，然后它就会称为新的栈顶元素，即head需要指向它。同理，元素出栈的时候，就是把head指针指向的链表元素删除即可。所以，链栈实际上就是一个采用**头插法**插入或删除数据的链表

**添加元素**

![](./images/链栈-入栈过程.gif)

**删除元素**：

![](./images/链栈-出栈过程.gif)

# 5.【队列】

队列是一种特殊的线性表，只能在头尾两端进行操作，属于先进先出原则的数据结构

- 队尾（rear）：只能从队尾添加元素，一般叫做入队
- 队头（front）：只能从队头移除元素，一般叫做出队

常见的队列实现：顺序队列、链式队列、双端队列、延迟队列、优先级队列....

![](./images/队列.png)

## 5.1.顺序循环队列

通过数组实现的队列，为了合理利用数组资源，一般会实现成**顺式循环队列**。顺序循环队列有一个问题：就是队列满和队列空的判断条件是一样的，需要特殊处理：

- 队列保留一个空位不保存数据，这样front和rear就不会在同一位置上;
- 增加一个字段，用来标注队列是否为空

**入队过程**

顺序循环队列底层实际也是数组，它会定义两个指针`top`和`near`，依次表示队首和队尾，当元素入队时`rear`指针就会+1。

![](./images/顺序循环队列-入队过程.gif)

而且，为了节省内存空间（队列假溢出），当rear达到`array.length-1`后，可以重新记为0，这样就可以继续允许元素入队，从逻辑上看就变成：

![](./images/顺序循环队列-逻辑循环结构.gif)

**出队过程**

元素出队过程，改变的时`top`指针，从队头出队。每次元素出队后，top++，指向下一个队头。正是由于元素出队了，所以`near`即使达到array.length-1，还是可以允许元素入队的。其实现还是跟上面的逻辑循环结构一样！

![](./images/顺序循环队列-出队过程.gif)

## 5.2.链式队列

链式队列，底层基于链表实现，所以它也不会有像普通顺序队列一样，造成`假溢出`的现象。链式队列一般会定义一个节点Node用于存储元素和下一个Node的引用，同时还会定义一个head指针，用于指向队首元素；定义top和rear指针表示队首元素和队尾元素：

![](./images/链式队列-初始状态.gif)

**入队过程**

链式队列可以有一个头节点（不存储任何元素），也可以没有。当有头节点的情况，元素`1`入队时，top指针不变，创建一个新的Node，将头节点的next指针指向这个Node，同时rear指针也指向这个Node，表示这个Node为新的队尾元素，这样元素`1`就入队成功了...依次类推，依次添加元素`2,3`：

![](./images/链式队列-入队过程.gif)

**出队过程**

由于头节点的存在，队首元素要出队，就要获取头节点的next指针指向的节点Node。当前队首元素为元素`1`，将其出队，将获取元素`1`节点的next指针指向的节点，即元素`2`，让头节点的next指针指向`元素2`，这样队首元素`1`就已经成功出队，top指针完全可以不用改变，一直指向头节点：

![](./images/链式队列-出队过程.gif)

## 5.2.双端队列

双端队列是可以在首尾两端执行添加、删除操作的队列

## 5.3.优先级队列

优先级队列，需要对入队的元素做优先级判断，优先级高的元素作为队头优先出队。根据优先级队列的特点，其实可以使用**二叉堆**作为它的底层实现！

# 6.【哈希表】

哈希表，也称为散列表，是使用hash函数实现的，一种典型的空间换时间思想的数据结构。哈希表经常会遇到一个问题：哈希冲突，也称为哈希碰撞，是指不同的key，通过哈希函数计算后得到相同的hashcode。解决哈希冲突的常见方法有：

1. 开放地址法，按照一定的规则向其它地址探测，直到遇到空桶；
2. 再哈希法，设计多个哈希函数，多次计算；
3. 链地址法，通过链表将同一个hashcode的元素串起来；

## 6.1.TreeMap

HashMap是无序的，而TreeMap是有序的

## 6.2.LinkedHashMap

LinkedHashMap可以记录元素添加的顺序

# 7.【跳表】

跳表（SkipList）也称为跳跃表、跳跃列表。是由William Pugh与1990年发布，设计的初衷是为了取代平衡树（比如红黑树）。跳表是在有序链表的基础上增加了“**索引**”的概念，通过每层索引来快速定位查询区间（有点二分搜索的思想）相较于平衡二叉树，跳表的实现和维护会更加简单，其搜索、删除和添加的平均复杂度都为O(logn)。那么，什么是跳表？

首先，跳表是一个有序链表，在有序链表的基础划分出不同层。最底层，也就是没划分过层次的，就是原原本本的链表，包含了所有元素：

![](./images/跳表-1.svg)

但是这样子，查询的时候只能从节点【3】开始，一个一个向后遍历，时间复杂度就是O(n)。但是很多元素其实没必要遍历，如果能跳过这些元素岂不美哉。所以，在最底层的基础，再重新划分一层：

![](./images/跳表-2.svg)

听过上面划分以后，链表就维护了一层索引：【6】→【9】→【17】→【21】→【26】，可以发现它比原始链表的元素少了很多，所以每次查询元素的时候，就可以先走这一层索引，然后略过那些没必要访问链表节点，这就是链表的核心思想了～为了能更快略过其它节点，会对跳表做多层索引：

![](./images/跳表-3.svg)

## 7.1.搜索

假设一个完整的跳表结构如下，如果现在要判断这个链表是否存在25，它的搜索过程如下

![](./images/跳表-3.svg)

1. 走最顶层的索引，即【null】→【21】→【null】，因为26>21，并且【21】后面就是【null】，没有机会可以再选择。因此，选择节点【21】开始搜索；
2. 最顶层定位到节点【21】，因此以节点【21】为基点向下层搜索，如图所示，搜索的结果就为【21】→【null】；
3. 第二层索引并不能确定，所以继续向下层搜索，第三层索引为【21】→【26】→【null】。很明显25处于21和26之间，所以选择【21】→【26】这一段，而不会选择【26】→【null】；
4. 来到第四层（在这个例子中也是最底层），因为在第3层中，已经可以确定25可能存在于【21】→【26】这区间。所以在第4层中 ，从走【21】→【25】→【26】这段索引即可，很明显了，一下子就可以定位到【25】

在这个过程中，在寻找25的过程，一开始就可以忽略掉从【3】到【21】这一段的节点，这就比普通链表一个一个遍历足足少了一半多的节点。然后，每一层可以定位到下一层要寻找的起点，直到没有层数可以访问了，那就说明元素确实不在跳表中~！跳表的搜索，总结起来就是：

- 从跳表顶层首元素开始，从左往右搜索，直至找到一个大于或等于目标的元素，或者到达当前层链表的尾部；
- 若该元素等于目标元素，说明元素已经找到，直接返回；
- 如该元素大于目标元素或已到达链表尾部，则退回到当前层的上一个元素，然后转入下一层，重复这个逻辑；
- 当访问完所有层，都未找到元素，说明它真的不存在；

## 7.2.添加

跳表的添加，跟搜索其实一样，首先它得先确定元素是否已经存在于跳表中，如果存在，那么直接覆盖旧值即可；如果不存在，那么需要一直遍历到跳表最底层，然后创建一个新节点，将其插进去。

![](./images/跳表-4.svg)

其中新节点的层数是随机的（官方也是随机的）那么问题的关键，就是怎么将新节点的每一层与原先跳表已存在的层关联起来。这就要求在遍历寻找的过程中，每次“拐弯”的节点必须记录下来，也就是每次切换层寻找的时候，都需要记录当前访问的这个节点，后面让新节点的每一层与这些拐点关联起来。一个完整跳表的添加过程如下：

![](./images/跳表-5.png)

## 7.3.删除

跳表删除就跟添加一样，区别在于，添加过程只要搜索到匹配节点，就可以直接返回；而删除不可以，因为他必须要为维护原先建立好的层关联。所以跳表的删除一定要遍历到最底层，如果元素不再跳表，就可以直接返回；如果元素存在于跳表，那么被删除节点的有效层内，将遍历过程中维护的每个“拐点”，将它们与被删除节点当前层的下一个节点关联起来~~最终让被删除节点直接脱离组织！