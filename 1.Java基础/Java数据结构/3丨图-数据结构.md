# `程序=数据结构+算法！`

# 1.基本概念

图是由顶点（Vertex）和边（Edge）组成，通常表示为`G=(V, E)`，其中`G`表示一个图，`V`表示顶点集，`E`是边集，要求顶点集`V`有穷且非空，任意两个顶点之间可以用边来表示之间的关系。

## 1.1.图的种类

图的种类很多，举几个常用的例子：

- **有向图**（Directed Graph）它的边是有方向的，比如`→`或者`←`；
- **有向无环图**（Directed Acyclic Graph）指的是一个有向图，从任意顶点出发无法经过若干边回到该顶点；
- **无向图**（Undirected Graph）它的边无方向，它可以等价于有向图两个顶点之间有两个方向相反的边；
- **无向完全图**：任意两个顶点之间都存在边；**有向完全图**：任意两个顶点之间都存在方向相反的边；
- **有权图**（Weighted Graph）这类图的边可以拥有权值
- **连通图**（Connectd Graph）若顶点X和顶点Y之间存在可以相互抵达的路径（间接或直接）则称X和Y是连通的。如果无向图G中任意2个顶点都是连通的，则称G为连通图
- .... ....

## 1.1.出度,入度

出度和入度，适用于有向图。

- 出度（Out-degree）是指：对于任意顶点，有x条边以它为起点，那么该顶点的出度就为x

- 入度（In-degree）是指：对于任意顶点，有x条边以它为终点，那么该顶点的入度就为x

下图中，顶点B的出度为3，入度为2

![](./images/有向图.png)

## 1.3.表示方式

由于图存在顶点和边的概念，需要同时保存顶点信息和边信息，所以图有两种表示：

- **邻接矩阵（Adjacency Matrix）**：底层就是二维数组`obj[x][y]`，一维数组表示顶点，即`x`表示顶点；二维数组表示边，即`obj[x][y]`表示一条边（如果顶点不存在边，默认取值为0，反之取值为1）如果边有权值可以赋予`obj[x][y]`特殊值。这种方式适合稠密图，即边占多数的情况。
- **邻接表（Adjacency List）**：底层就是链表，一个顶点就是一个链表，链表的引用链表示该顶点能通往的其它顶点。假设用节点类`Node`表示节点，如果`Node.next`不为空，说明`Node`和`Node.next`存在一条边；再如果`Node.next.next`不为空，说明`Node`和`Node.next.next`也存在一条边。当然如果边有权值，可以在`Node`定义一个字段用来保存边的权值。（实际实现不会严格按照这种方式，还有，其实还有一个相反的实现称为`逆邻接表`，它表示的哪些顶点能到达当前顶点）

![](./images/无向图的表示方式.jpg)

![](./images/有向图的表示方式.jpg)

# 2.图的遍历

图的遍历：从图中的某一顶点出发，访问图的其它顶点，并且每一个顶点只会被访问一次。图的遍历有两种方式：

- 广度优先搜索遍历，Breadth First Search，简称**BFS**，又称为横向优先搜索、宽度优先搜索
- 深度优先搜索遍历，Depth First Search，简称**DFS**

## 2.1.广度优先搜索

二叉树的层序遍历，实际上就是一种广度优先搜索（实际上就可以参考二叉树层序遍历的实现思路 — 队列，来实现图的广度优先搜索遍历）。它是一种“地毯式”层层推进的搜索策略，即**先查找离起始顶点最近的，然后是次近的，依次往外搜索**。图的广度优先搜索思路是这样：

1. 首先明确从图的某一个顶点出发，记为R。访问R，完成第一层遍历；
2. 以R为起点，寻找与R只隔一条边的顶点集V，访问它们完成第二层遍历；
3. 依次以V中的顶点R<sub>v</sub>为起点，同第2步一样，寻找与R<sub>v</sub>只隔一条边的顶点集V<sub>2</sub>，访问它们完成第三层遍历；
4. ...以此类推，访问过的顶点不能重复访问，最终就可以实现广度优先搜索。

![](./images/图-广度优先搜索.png)

当选择的起点不一样时，得到的广度优先搜索就会不一样。这一现象，尤其在有向图中表现明显，以上图为例：

1. 如果选择顶点【5】为起点，第一层遍历就是先访问【5】自身
2. 接着从顶点【5】出发，它有两条出度的边【5→6】和【5→7】，所以第二层遍历就是访问顶点【6】和【7】
3. 接着从顶点【6】和【7】出发，【7】的出度只有一条边就是到顶点【6】，但是顶点【6】已经访问过了，所以不会再访问；从顶点【6】出发，它只有一条出度边即【6→2】，所以第三层遍历就是访问顶点【2】
4. 接着从顶点【2】出发，它的出度为也只有一条【2→0】，所以第四层访问就是顶点【0】
5. 接着从顶点【0】出发，它的出度为0，所以广度优先搜索结束

## 2.2.深度优先搜索

二叉树的前序遍历，实际上就是一种深度优先搜索（实际上就可以参考二叉树前序遍历的实现思路 — 递归，来实现图的广度优先搜索遍历）。它会**沿着树的深度遍历树的节点，尽可能深得搜索树的分支，当节点v的所在边都己被探寻过，搜索将回溯到发现节点v的那条边的起始节点**。这一过程一直进行到已发现从源节点可达的所有节点为止。图的深度优先搜索思路是这样：

1. 首先明确从图的某一个顶点出发，记为R，直接访问R；
2. 以R为起点，选择它的一条边，选取这条边的终点记为R<sub>2</sub>，直接访问R<sub>2</sub>；
3. 以R<sub>2</sub>为起点，选择它的一条件，选取这条边的终点记为R<sub>3</sub>，直接访问R<sub>3</sub>；
4. ... ...以此类推，直到访问顶点R<sub>n</sub>，它已经没有边，就会回溯到上次访问顶点R<sub>n</sub>时用的那条边的起点R<sub>n-1</sub>;
5. 选择R<sub>n-1</sub>的其它边进行访问，如果R<sub>n-1</sub>也没有边了，继续回溯到R<sub>n-2</sub>；
6. ... ... 以此类推，直至回溯到最开始的顶点即R，选取它的其它边继续访问，如果它也没有边可以访问了，那就意味着以R为起点的深度优先搜索结束。

![](./images/图-深度优先搜索.png)

选择的起点不一样，深度优先搜索的结果就会不一样，而且会有多种遍历结果。以右上图的第一行访问结果为例：

1. 选取顶点【a】为起点，先访问【a】
2. 【a】存在两条出度边【a→b】和【a→e】，先选取【a→e】，访问顶点【e】；
3. 【e】存在两条出度边【e→c】和【e→f】，先选取【e→f】，访问顶点【f】；
4. 【f】存在一条出度边【f→c】，那就直接访问【c】；
5. 【c】存在一条出度边【c→b】，那就直接访问【b】；
6. 【b】存在一条出度边【b→e】，但是顶点【e】在第2步就已经访问过了，所以不再访问，而且【b】也没有其它出度边了，所以回溯到【c】（原先是通过【c→b】这条边来访问顶点【b】的）；
7. 【c】也没有其它出度边了，所以回溯到【f】（原先是通过【f→c】这条边来访问顶点【f】的）；
8. 【f】同样也没有其它出度边了，回溯到【e】；同理【e】也没有其它出度边，继续回溯到【a】；
9. 【a】有两条出度边【a→b】和【a→e】，【a→e】已经访问完了，所以就会选取另外一条边即【a→b】开始访问，但实际上顶点【b】在第5步已经访问过，所以【a→b】这条边就不会再开启新一轮深度优先搜索；
10. 到此，以【a】为起点的深度优先搜索结束！