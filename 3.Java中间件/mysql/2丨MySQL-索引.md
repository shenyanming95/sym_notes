# 1.索引基础

索引，index，是一种排好序的，能够实现快速查找的数据结构。索引的出现，可以提高数据的查询效率。

## 1.1.实现

实现索引的方式有很多种，统称为`索引模型`。常见的有：哈希索引、有序数组和搜索树，后续也有加入了跳表、LSM树等数据结构。

- 哈希索引：只适用于等值查询的场景
- 有序数组：适用于等值查询和范围查询，但是涉及增删改时，需要移动大量元素，所以仅仅适合静态存储
- 搜索树：比较常用的索引模型，大部分都是多叉树，例如 B 树和 B+树

B 树，索引和数据同存储在各个节点上，MongoDB便使用 B 树作为索引

![](./images/B树.png)



B+树，相较于 B 树，B+树的数据只存储在叶子节点上，并且它的叶子节点之间存在一个引用。mysql 底层就是使用 B+树索引

![](./images/B+树.png)

## 1.2.分类

索引可以按照不同的角度来分类：

- 以结构来划分：
  - 单值索引：一个索引只包含一个列，一个表可以有多个单值索引
  - 复合索引：一个索引包含多个列
  - 唯一索引：索引列的值必须唯一，允许有空值

# 2.InnoDB索引类型

在InnoDB中，表都是根据主键顺序以索引的形式存放的，这种存储方式的表称为索引组织表，每一个索引在InnoDB里面对应一棵B+树，所以数据都是存储在B+树中的。索引类型分为主键索引和非主键索引。

- 主键索引的叶子节点存的是整行数据。在InnoDB里，主键索引也被称为聚簇索引（clustered index）
- 非主键索引的叶子节点内容是主键的值。在InnoDB里，非主键索引也被称为二级索引（secondary index）

所以，如果按照主键来查询，直接扫描主键索引所在的B+树即可，但是如果按照非主键来查询，就需要先查询二级索引所在的B+树，得到主键值后，再来查询主键索引所在的B+数，这一过程称为**回表**。即基于非主键索引的查询需要多扫描一棵索引树。所以为什么说select后面的字段如果是索引，即覆盖索引操作，速度会很快？原因就是InnoDB直接在索引上分析读取，少了回表操作。

## 2.1.覆盖索引

如果 select 查询的字段就是索引，那么称这种操作为覆盖索引。覆盖索引可以减少树的搜索次数（减少回表次数），显著提高查询效率

## 2.2.索引下推

假设创建了一个索引，包含两个字段（name, age），执行下面的 SQL：

```sql
select * from user where name like '张%' and age=10 and ismale=1;
```

由于我们创建了一个联合索引（name,age）而且where 的查询条件第一个就是 name，可以匹配到我们创建的索引；在MySQL 5.6之前，通过索引（name,age）匹配到`张`后找出行的主键 ID，然后开始一个个回表，到主键索引上找出数据行，再对比字段值`age`，过滤出等于 10 的行记录。而MySQL 5.6 引入的索引下推优化（index condition pushdown)， 可以在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数。

# 3.性能分析

MySQL架构在第二层有一个Mysql Query Optimizer，是MySQL官方提供的查询优化器，它负责优化select语句，为客户端请求的SQL提供MySQL自己认为最优的执行计划；**通过explain关键字，可以模拟优化器执行SQL查询语句，分析查询语句或表结构的性能瓶颈**。它的语法很简单，直接在SQL前面加`explain`关键字即可

```sql
explain select * from  t_dept
```

**explain关键字字段描述：**

| 列名          | 描述                                                 |
| ------------- | ---------------------------------------------------- |
| id            | 与SELECT关键字对应                                   |
| select_type   | SELECT关键字对应的查询的类型                         |
| table         | 表名                                                 |
| partitions    | 匹配的分区信息                                       |
| type          | 单表的访问方式                                       |
| possible_keys | 可能会用到的索引                                     |
| key           | 实际使用的索引                                       |
| key_len       | 实际使用到的索引长度                                 |
| ref           | 使用索引列等值查询时，与索引列进行等值匹配的对象信息 |
| rows          | 预估计的需要读取的记录条数                           |
| filtered      | 单表经过搜索条件过滤后剩余记录条数的百分比           |
| Extra         | 一些额外的信息                                       |

## 3.1.id

id是select识别符，也是select查询的序列号，包含一组数字用来表示查询中执行select子句或操作表的**顺序**！规则如下：

- **id相同，执行顺序从上到下**

  ![](./images/explain之id_1.png)

  上例的执行顺序便是：t1，t3，t2。虽然例子中sql语句的`from`后面的表顺序是：t1，t2，t3，但是mysql并不会按照这种顺序去执行，它通过查询优化器分析以后，认为t1，t3，t2的执行顺序更优良，从sql语句的角度分析，where条件最后的and是跟表t1有关，因此mysql会优先查询表t1的数据

- **id 值不同，id 值越大优先级越高，如果是子查询，id 值会递增然后优先执行**

  ![](./images/explain之id_2.png)

  若explain分析得到的结果，id的值各不相同，那么值越大的，越先执行。因此上例的执行顺序是：t3，t1，t2。从sql语句来看，查询表t2需要先查询表t1，而查询表t1又需要先查询表t3，或者这样子看，有括号的先查询，t2是在最外面，因此它最晚查，t1在里面，t3在最里面，所以t3最早查

- **id值既有相同的又有不同的**

  ![](./images/explain之id_3.png)

  sql语句`select t2.* from (...) s1`，from后面不是跟着表名而是跟着一个子查询，意思是把这个子查询的结果当做一个虚表，为这个虚表命名为s1，然后再从s1中查找数据，虚表有一个官方称呼—**衍生表**（derived是衍生的意思，即sql语句中的s1，表示衍生表。derived2中的2，表示这个衍生表是由id=2执行的那个表(即t3)衍生出来的）若分析后的结果，id的取值有相同的也有不同，像上例的1，1，2。这时候，相同id的为一组，按照从上往下的顺序执行；不同组间，id值大的优先级高，先执行。例如1，1为一组，2单独为一组；然后看id的值，id=2的值大，因此它先被执行，然后执行1，1这组，由于这一组id的值相同，因此是按从上往下的顺序执行，总的顺序是： t3，\<derived2>，t2。从sql语句来看，先执行括号里面的即先执行t3，t3执行完以后衍生出一个虚表s1，然后再执行这个虚表和t2，所以才会得到：t3，\<derived2>，t2的执行顺序


## 3.2.select_type,table

- table：指明这一行的数据是关于哪张表；

- select_type：指明数据查询时的操作类型，主要是用于区别普通查询、联合查询、子查询等复杂查询，有6种取值：

  - simple：简单的select查询，查询中不包含子查询或者Union；

  - primary：查询中若包含任何复杂的子查询，最外层查询则被标记为primary；

  - subquery：在select或where列表中包含了子查询；

  - derived：在from列表中包含的子查询被标记为derived（衍生）mysql会递归执行这些子查询，把结果放在临时表里；

  - union：若第二个select在Union之后，则被标记为union；若union包含在from子句的子查询中，外层select被标记为derived；

  - union result：从union表获取结果的select。

## 3.3.type

type指访问类型排列，表示SQL语句的查询效率，常用的取值有：`ALL、index、range、ref、eq_ref、const、system、null`。性能从最好到最坏依次是：`null > system > const > eq_ref > ref > range > index > all`。一般来说，得保证查询至少达到range级别，最好能达到ref级别~~

- system：表明表里面仅有一条记录(相当于系统表)，是const的特例，平常几乎遇不到，因此可以忽略

- const：表明表最多只有一条匹配行，表示通过索引一次就找到数据，常用于主键或unique索引，因为只匹配一行数据，所以很快

  ![](./images/explain之type-const.png)

  当在查询`select * from t1 where id=1`时，由于是用主键来查询的，主键值是唯一的，所以表中有且仅有一条数据与之匹配，这时候mysql就能将该查询转为一个常量，则type=const，将查询后的结果当成衍生表d1，由于查询结果只有一个，所以d1只有一条记录相当于系统表，此时查询，type便为system类型

- eq_ref：多表联接唯一性索引扫描，对于前表的每个索引键，后表只有一条记录与之匹配，常见于主键或唯一索引扫描，eq_ref可用于使用`=`比较带索引的列

  ![](./images/explain之type-eq_ref.png)

  比如，t1是员工表，t2是部门表，t2的主键id是t1的外键。 id值若相同，按从上往下的顺序查询，因此先查询部门表t2，对t2的查询方式是全表扫描，找到t2所有的部门id，然后对员工表t1查询，找出与前表(t2表)找到的id匹配的员工，当此时t1只有一条记录时，type的值便是eq_ref。换句话说，当找的部门是研发部，会有多条记录，因为研发的员工有多个，当找的是总裁部时，仅有一条记录.

- ref：区别于eq_ref，因为ref是非唯一性索引扫描，它返回匹配某个索引值的所有行，它可以找到多个符合条件的行

  ![](./images/explain之type-ref.png)

  当没有建索引去查询col1='ac'的表数据，type的类型为all，只能是全表扫描。当建立了索引：create index idx_col1_col2 on t1(col1,col2)，再去查询col1='ac'的数据，mysql用索引去查找，且col1字段并不是表t1的主键，没有唯一性，查出来的数据会有多条，此时的type的类型就是ref

- range：只检索给定范围的行，使用一个索引来选择行，一般就是where语句出现了`between、<、>、in`等查询。这种范围扫描索引比全表扫描好，因为它只需要开始于索引的某一点，结束于另一点，不用扫描全表

  ![](./images/explain之type-range.png)

- index： index与all区别在于index类型只遍历索引树。这通常比all快，因为索引文件通常比数据文件小，虽然all和index都是读全表，但是Index是从索引中读取的，而all是从硬盘读取的。id是表t1的主键，所以select id就是直接从索引里面遍历：

  ![](./images/explain之type-index.png)

- all：会遍历全表找到匹配行，不使用索引，就只能全表扫描

## 3.4.possible_keys,key

- possible_keys：表明执行SQL时理论上需要用到的索引列表，若查询涉及到的字段上存在索引，则该索引被列出，但不一定实际使用
- key：表明实际使用的索引，如果为null则没有使用索引。但是，如果 select 的是覆盖索引列，那么该索引仅会出现在key列表中，possaible_key会显示null

## 3.5.key_len

key_len：表示索引中使用到的字节数，通过该列计算出查询时使用的索引长度，查询条件越多，用的key_len就会越大，得出的结果就会越精确。不过在查询结果一样的前提下，key_len越小越好。

## 3.6.ref

ref，表示哪些列或常量被用于查找索引列上的值，如果使用的是常数等值查询，ref会显示const；如果是连接查询，ref会显示驱动表的关联字段；如果使用表达式或者函数，或条件列发生了内部隐式转换，ref可能显示为func

![](./images/explain之ref.png)

id值相同，执行顺序由上至下，此条SQL的表查询顺序是t1，t3，t2。

- 查询t1时，ref=const即常量，结合sql语句t1.othe_column=''是匹配一个空字符串来查询数据，空字符串就是一个常量

- 查询t3时，ref=test.t1.ID，用的列是test数据库的t1表的ID列，结合sql语句...and t1.id = t3.id，以t1表为驱动表，来查找t3表中符合条件的数据

- 查询t2时，ref=test.t1.ID，意思也是用test数据库的t1表的ID列，因为查询t2的sql语句为 where t1.id = t2.id，跟查询t3表的语句时一样的

## 3.7.rows

rows，根据表统计信息及索引选用情况，大致估算出找到所需记录要读取的行数

## 3.8.extra

extra，包含不适合在列中显示但十分重要的额外信息。最重要的3个取值： using filesort、using temporary 、using index

- **using filesort**

  说明这条sql不是按照表内的索引顺序排序，而是用了一个外部的索引排序，Mysql中无法利用索引完成的排序操作称为"文件排序"，即filesoft。一般表现在带有order by等排序关键字的sql语句上，出现using filesort表示性能不好 

- **using temporary**

  出现using temporary，则Mysql要赶紧优化，性能极其不好。它表明MySQL在对查询结果排序时使用了临时表，常见于排序order by和分组查询group by

- **using index**

  using index的出现，表示效率不错，是良好的表现。它表示相应的select操作中使用了覆盖索引，避免访问了表的数据行，若同时出现using where，表明索引被用来执行索引键值的查找；若没有同时出现using where，表明索引用来读取数据而非查找动作

# 11.性能优化

## *.1.何时需要索引？

- 需要索引的情况

  - 主键自动建立唯一索引

  - 频繁作为查询条件的字段

  - 查询与其他表关联的字段，外键关系建立索引

  - 查询中排序的字段，排序字段若通过索引去访问将大大提高效率

  - 查询中统计或者分组字段

- 不需要索引的情况
  - 经常增删改的表、频繁更新的字段（不仅要更新数据，还要维护索引树）
  - where条件里用不到的字段不创建索引
  - 表记录太小，Mysql据说可以撑到300W条
  - 某个数据列包含许多重复的内容，例如性别，都是男或者女，没必要建索引

## *.2.索引优化

### *.2.1.最佳左前缀法则

最佳左前缀法则：**如果索引了多列，查询条件要从索引的最左前列开始并且不跳过中间的列**。现在有一个学生表，该表的索引如下：

![](./images/索引优化-最佳左前缀法则_1.png)

红框标注的索引列，从上往下的顺序是name->age->sex，where语句后的查询条件，name一定要存在，就像：

![](./images/索引优化-最佳左前缀法则_2.png)

从explain解析出来的信息，可以看到type是ref而且key不为null，说明建立的索引有用到，但如果where后name没用到，不论后面怎么搞，索引也用不到，所以说，索引的最左前列在where后一定要体现，否则如下：

![](./images/索引优化-最佳左前缀法则_3.png)

第二点，where语句后的查询条件，不要name='' and sex = ''，而把中间索引列age省略掉。当索引列都拿来做查询条件时，由type=ref知道肯定用了索引，从ref=const,const,const知道3个常量都拿去查询了

![](./images/索引优化-最佳左前缀法则_4.png)

但是，如果中间去掉age的查询条件，由于带头大哥name在，所以肯定是会用到索引，但是从ref=const可得只用到了一个常量，后面那个常量根本用不到：

![](./images/索引优化-最佳左前缀法则_5.png)

### *.2.2.索引列不加操作

不要在索引列上做任何操作（计算、函数、类型转换等），会导致索引失效。left(v,n)函数是Mysql自带的函数，意思是在指定的列v上，从左往右数起到n得到的值与给定的值相匹配的数据，可以看到查询的结果与...where name='张三'的结果是一样的

<img src="./images/索引优化-索引列不加操作_1.png" style="zoom:67%;" />

但是，由于在索引列上加了其他操作，导致索引失效，用explain分析后发现，mysql居然是用了全表扫描来查询数据，所以，索引列就直接拿去查询，不要做过多的修饰和包装

![](./images/索引优化-索引列不加操作_2.png)

### *.2.3.范围条件后索引列失效

在where条件后，如果某列用了范围条件（如in，between，>，<等）则此列以后的索引列都会失效，mysql并不会再用索引去查询：

![](./images/索引优化-范围条件后索引列失效_1.png)

当等值查询name='张三' and age=21时，因为用了2个常量，key_len=156；全值查询name='张三' and age=21 and sex='m'，用了3个常量，key_len-=159；一旦在查询条件中，加了范围条件的查询，像name='张三' and age>21 and sex='m'，观察key_len=156，很明显可以知道跟2个条件等值查询一样，也就是说虽然sql语句用了3个条件来查询，但由于用了范围条件age>21导致sex='m'这个条件失效，所以在建立索引时候，要将可能用到范围查询的列放到最后

索引idx_name_age_sex的最后一列是sex，我们在sex列上用范围查询，可以看到key_len=159，跟3个条件等值查询用到的索引字节数一样：

![](./images/索引优化-范围条件后索引列失效_2.png)

### *.2.4.尽量避免select\*查询

尽量使用覆盖索引（查询列和索引列一样），减少select * 操作。我们把select *改成select name age后，对比一下，发现Extra列多了一个Using index，当出现using index表示系统性能更好，所以，当我们在查询的时候尽可能地保证查询的列能和索引列一样，这样Mysql直接从索引上取值，极大地加大性能：

![](./images/索引优化-避免select全查询.png)

### *.2.5.!=，<>会使索引失效

mysql在使用不等于（!=或者<>）的时候，无法使用索引导致全表扫描。备注：在mysql中，<>相当于!=，即不等于的意思；<=>相当于=，即等于的意思

![](./images/索引优化-不等符号使索引失效_1.png)

由上图知道，使用了!=时，性能直接由ref级别下降到all级别。但是如果是唯一性索引，例如主键，就算用了!=，索引也可以使用，变为range类型：

![](./images/索引优化-不等符号使索引失效_2.png)

### *.2.6.is null或is not null索引失效

当查询条件是..is null或者.. is not null的时候，由下图可以看出出现两种情况：一种是极端type=null，一种是全表扫描type=all，尽量避免使用！

![](./images/索引优化-is null或 is not null使索引失效.png)

### *.2.7.模糊查询like

like以通配符开头（'%xxx...'）mysql索引失效会变成全表扫描的操作。即：'%java'、'%java%'都会失效，但是'java%'就不会失效：

![](./images/索引优化-避免模糊查询like_1.png)

可是这样有个问题，条件'java%'和'%java%'查到的数据肯定是不一样的，而且在一般情况下，用'%java%'是最多的，咋保证既要双向模糊查询又不能让索引失效？答案是：覆盖索引，当查询的列与索引列一致，即使用like索引也不会失效：

![](./images/索引优化-避免模糊查询like_2.png)

表中建立索引用的列是name、age、sex，还有主键列：id。可以发现，在select查询的列是这四列的任意组合时，type=index，虽不说很高效，但至少比全表扫描ALL好很多，一旦select查询的列是非索引列(如多了addr)可以看到，查询结果type=ALL，继续变成全表扫描。结论：**使用模糊查询like，尽量保证查询列与索引列一致，即覆盖索引**

### *.2.8.字符串不加引号使索引失效

当一个varchar类型的数据，查询时不使用引号，会发生隐式类型转换，导致索引失效，进而变成全表扫描，其实就是避免在索引列上加操作

![](./images/索引优化-字符串不加引号索引失效.png)

### *.2.9.尽量避免or条件查询

加了or条件的查询，会让索引失效，变成全表扫描

![](./images/索引优化-避免or查询.png)

## *.3.小表驱动大表

优化原则：**永远保持小的数据集驱动大的数据集！**比如`in`和`exist`：

- `in`作用于子查询，它是将子查询的结果用于主查询的条件匹配，若子表数据集小于主表数据集，用`in`；
- `exist`作用于主查询，它是将主查询的数据放到子查询中做条件验证，根据验证结果(true或false)来决定主查询的数据结果是否得以保留，若子表数据集大于主表数据集，用`exist`

```sql
select * from A where id in(select id from B)
-- 等价于
select * from A where exists(select 1 from B where B.id=A.id)
```

## *.4.order by

MySQL支持2种方式的排序：文件排序`using filesort`和索引排序`using index`，出现`filesort`表示系统性能出现问题，所以要让MySQL使用index索引排序，需要满足下面情况的任意一种：

- 排序的列必须也是是索引列

- 索引最左列（上例中的a列）一定要体现

- 排序列要么同升序要么同降序

## *.5.group by

group by与order by大致一样，以下三种情况是group by独有的：

- group by实质是先排序后进行分组，遵循创建索引时的最佳左前缀法则

- 当无法使用索引列，在Mysql配置文件中增大max_length_for_sort_data参数和sort_buffer_size参数的值

- where高于having，能写在where限定的条件就不要去having限定了