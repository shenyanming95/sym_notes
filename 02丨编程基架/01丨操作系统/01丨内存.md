# 1.理论

## 1.1.内存条

内存，也叫DRAM，即动态随机存储器。本质上它就是下图所示的条型组件：

![](https://static001.geekbang.org/resource/image/0d/8e/0d0d85383416f2f8841aeebe7021a88e.jpg?wh=3541*1553)

在 PCB 板上有内存颗粒芯片，主要是用来存放数据的。SPD 芯片用于存放内存自身的容量、频率、厂商等信息。还有最显眼的金手指，用于连接数据总线和地址总线，电源等。

内存储存颗粒芯片中的存储单元是由电容和相关元件做成的，电容存储电荷的多、少代表数字信号 0 和 1。而随着时间的流逝，电容存在漏电现象，这导致电荷不足，就会让存储单元的数据出错，所以 DRAM 需要周期性刷新，以保持电荷状态。因此内存需要不断地供电。

**逻辑上我们只需要把内存看成一个巨大的字节数组就可以，而内存地址就是这个数组的下标**。

## 1.2.局部性原理

局部性原理：在程序的执行过程中，数据和指令的访问往往具有局部集中的特点。主要包括以下两个方面：

1. 时间局部性（Temporal Locality）：时间局部性指的是程序在一段时间内对某个数据或指令的多次访问。当程序执行一条指令或者访问一个数据时，很可能在近期的某个时间点再次访问同样的指令或数据。这是因为在程序中，往往会有循环结构、重复的子程序调用等，导致某些数据和指令在短时间内被多次使用。
2. 空间局部性（Spatial Locality）：空间局部性指的是程序在一段时间内访问的数据或指令在空间上彼此相邻。当程序访问某个数据或指令时，它很可能会在附近的内存位置访问其他相关的数据或指令。这是因为程序的数据和指令通常以连续的块或者相邻的存储位置进行存储，因此对一个数据或指令的访问往往会引起对附近数据或指令的访问。

通过这个原理可得到一个结论：无论一个进程占用的内存资源有多大，在任一时刻，它需要的物理内存都是很少的

# 2.虚拟内存

计算机运行的所有数据都会落到物理内存里，在早期的CPU指令集里，从内存加载数据、向内存写入数据都是直接操作物理内存。在嵌入式设备中，这种操作是正常的，毕竟嵌入式设备正常只有一个应用在执行；但是在多任务的操作系统中，进程直接操作物理内存，容易出错和冲突，因此设计了虚拟内存。

每个进程拥有独立且隔离的虚拟内存，进程可以将数据存放到虚拟内存中，进程持有的虚拟地址会通过 CPU 芯片中的内存管理单元（MMU）的映射关系，来转换变成物理地址，然后再通过物理地址访问内存。

![](https://static001.geekbang.org/resource/image/4b/48/4bae735761c77bd0efa26974c8f53548.jpg?wh=2284x1238)

1. 虚拟内存虽然提供了很大的空间，但进程启动后，这些空间并不是全部都能使用，还是需要显式调用malloc等内存分配接口才能将内存从『待分配』状态变成『已分配』
2. 分配得到一块虚拟内存后，它属于『未映射』状态，此时它并没有被映射到物理内存中。直到对这块内存进行读写时，CPU才会真正为其分配物理内存；
3. 虚拟内存中连续的页面，在物理内存不一定是连续，只要维护好映射关系即可正常使用内存地址。这种映射关系是通过页表来实现；
4. 虚拟内存的地址空间和机器字宽有关，32位机器，指向内存的指针是32位，因此它的虚拟地址空间是2<sup>32</sup>，也就是4GB；64位机器，指向内存的指针是64位的，但实际只使用了低48位，因此它的虚拟地址空间是2<sup>48</sup>，也就是256T。

## 2.1.分段式

操作系统早期使用『内存分段』的方式管理虚拟内存和物理内存之间的映射。分段机制下的虚拟地址由两部分组成，**段选择子**和**段内偏移量**。

![](./images/分段式内存管理-1.jpeg)



- **段选择子**就保存在段寄存器里面。段选择子里面最重要的是**段号**，用作段表的索引。**段表**里面保存的是这个**段的基地址、段的界限和特权等级**等。
- 虚拟地址中的**段内偏移量**应该位于 0 和段界限之间，如果段内偏移量是合法的，就将段基地址加上段内偏移量得到物理内存地址。 

![](./images/分段式内存管理-2.jpeg)

分段机制会把程序的虚拟地址分成 4 个段，每个段在段表中有一个项，在这一项找到段的基地址，再加上偏移量，于是就能找到物理内存中的地址：要访问段 3 中偏移量 500 的虚拟地址，我们可以计算出物理地址为，段 3 基地址 7000 + 偏移量 500 = 7500。

【分段式的缺点】

- 产生大量的**内存碎片**
- **内存置换（swap）的效率低**

## 2.2.分页式

内存分段会出现内存碎片和内存交换太大的问题，要想解决这个问题，减小内存管理单元的大小即可，也就是内存分页：**分页是把整个虚拟和物理内存空间切成一段段固定尺寸的大小**。这样一个连续并且尺寸固定的内存空间，我们叫**页**（*Page*）。在 Linux 下，每一页的大小为 `4KB`。

分页机制下，虚拟地址分为两部分，**页号**和**页内偏移**。页号作为页表的索引，**页表**包含物理页每页所在**物理内存的基地址**，这个基地址与页内偏移的组合就形成了物理内存地址：

![](./images/分页式内存管理-1.jpeg)

对于一个内存地址转换，三个步骤：

- 把虚拟内存地址，切分成页号和偏移量；
- 根据页号，从页表里面，查询对应的物理页号；
- 直接拿物理页号，加上前面的偏移量，就得到了物理内存地址。

------

在实际场景中，如果只用一层分页，会导致页表非常庞大：32 位的环境下，虚拟地址空间共有 4GB，假设一个页的大小是 4KB（2<sup>^</sup>12），那么就需要大约 100 万 （2<sup>^</sup>20） 个页，每个「页表项」需要 4 个字节大小来存储，那么整个 4GB 空间的映射就需要有 `4MB` 的内存来存储页表。因此实际使用：多级页表，把这个 100 多万个「页表项」的单级页表再分页，将页表（一级页表）分为 `1024` 个页表（二级页表），每个表（二级页表）中包含 `1024` 个「页表项」，形成**二级分页**：

![](./images/分页式内存管理-2.jpeg)

此时内存转换步骤变为：

1. 确定页目录基址：每个CPU都有一个页目录寄存器，最高级页表的基地址存在这个寄存器。在X86上，这个寄存器是CR3，每次计算物理地址，MMU都会从CR3寄存器中取出页目录所在的物理地址
2. 定位页目录项（PDE，即上图的一级页号）：一个32位的虚拟地址可以拆成 10位、10位和12位三段。第1步找到的页目录表基址加上高10位的值乘以4，就是页目录项的位置。（页目录项是4字节，1024个页目录项组成一页，正好是 4 * 1024k = 4kb，而1024个页目录项需要10位编码，所以可以通过高10位找到对应PDE）
3. 定位页表项（PTE，即上图的二级页号）：第2步找到页目录项记录着页表的位置，CPU通过页目录项找到页表的位置后，再用中间10位计算页表中的偏移，可以定位该虚拟地址对应的页表项（PTE）。
4. 确定物理地址：第3步CPU定位到页表项，它存储着物理地址，也就能找到改虚拟地址对应的物理页。此时虚拟地址还剩下12位，刚好对应物理页的所有字节（一个物理页4kb = 4 * 1024b = 2<sup>^</sup>12b）因此可以用12位来表示业内偏移，直接通过物理页的地址加上虚拟地址的低12位。

------

对于64位系统，演变成4级目录：

- 全局页目录项 PGD（*Page Global Directory*）；
- 上层页目录项 PUD（*Page Upper Directory*）；
- 中间页目录项 PMD（*Page Middle Directory*）；
- 页表项 PTE（*Page Table Entry*）；

![](./images/分页式内存管理-3.jpeg)

# 3.内存布局

当程序保存在磁盘时，它的每一个单元结构被称为Section；当程序被加载到内存时，它的每一个单元结构被称为Segment。Segment会将具有相同权限属性的Section集映射到一起，为它们分配一块内存空间，因此往往多个Section对应一个Segment，例如：

- `.text`、`.rodata`等只读的Section，会映射到内存的「只读/执行」权限的Segment里；
- `.data`、`.bss`等可读写的Section，会映射到内存的「读写」权限的Segment里；
- `.symtab`、`.strtab`等磁盘二进制的一些辅助信息的Section，不会在内存中映射；

![](https://static001.geekbang.org/resource/image/bc/c9/bca1533a0af7ee8476yy12f4b04083c9.jpg?wh=2284x1319)

## 3.1.逻辑布局

![](https://static001.geekbang.org/resource/image/fc/c0/fcb6231d9cc3841643e4b84462e5b3c0.jpg?wh=2284x1980)

CPU运行一个程序，需要将存放在磁盘的进程文件载入内存，因此就会有进程的内存布局：

- 代码段：存储程序的机器码
- 数据段：在程序源代码中，对于有初值的变量，它的初始值会存放在程序的二进制文件。那么在加载这个程序的时候，这些数据也会被装载到内存中，即程序的数据段。因此，数据段存放的是程序中已经初始化且不为0的全局变量和静态变量
- BSS段：已经初始化的全局变量和静态变量会存放在「数据段 」，而对于未初始化的，编译器知道默认值都是0，所以不需要将其保存到二进制文件，进而就不需要加载到「数据段」，只需要记录它们的大小，此时就会存储到BSS段（全称是 Block Started by Symbol，也被记为 Better Save Space）
- 栈/堆：「数据段」和「BSS段」都会存储变量，主要是全局变量和静态变量。但在程序运行期间，还需要记录临时变量和运行时产生的变量，这些会被存储在「堆空间」和「栈空间」

以上是一个进程运行的基本内存布局，现代应用程序还会包含其它区域，主要是：

1. 存放加载的共享库的内存空间：如果一个进程依赖共享库，那对应的，该共享库的代码段、数据段、BSS 段也需要被加载到这个进程的地址空间中
2. 共享内存段：我们可以通过系统调用映射一块匿名区域作为共享内存，用来进行进程间通信
3. 内存映射文件：我们也可以将磁盘的文件映射到内存中，用来进行文件编辑或者是类似共享内存的方式进行进程通信

## 3.2.IA-32位

32位机器上，每个进程具有4GB的寻址能力，Linux默认将高地址的1GB空间分配给内核，剩余的低3GB是用户可以使用的用户空间

![](https://static001.geekbang.org/resource/image/61/b2/61ee74faa861797b34397ed837a027b2.jpg?wh=2284x1808)

## 3.3.Intel-64位

目前，Intel 64 处理器往往支持 48 位的虚拟地址，则寻址空间是 2^48，即 256TB。将低 128T 的空间划分为用户空间，高 128T 划分为内核空间：

![](https://static001.geekbang.org/resource/image/12/1c/1258dabe44e33c66c0f423d8d24a8f1c.jpg?wh=2284x1578)

# 4.栈

堆的空间有一个向下的箭头，标明栈地址空间的增长方向（栈地址是向低地址方向增长），每次进程再向内核申请新的栈地址时，其地址值是减少的。栈的指针叫做“Stack pointer”

# 5.堆

堆的空间有一个向上的箭头，标明堆地址空间的增长方向，每次进程再向内核申请新的堆地址时，其地址值是增大的。堆的指针叫做“Program break”

## 5.1.申请堆空间

不管是 32 位系统还是 64 位系统，内核都会维护一个变量 brk，指向堆的顶部，所以，brk 的位置实际上就决定了堆的大小。Linux系统提供了两个重要的系统调用来修改堆的大小，分别是sbrk和mmap。

【sbrk】

```c
#include <unistd.h>
void* sbrk(intptr_t incr);
```

sbrk函数通过给内核的brk变量增加`incr`以改变堆的大小，当`incr`为正数，堆增大；当`incr`为负数，堆减小。函数执行成功，返回brk变量的旧值；执行失败，返回-1，同时将errno设置为ENOMEM。

在C语言的运行库里，提供了 malloc() 和 free() 实现堆内存的分配和回收。但其实，C语言的运行库使用sbrk()向操作系统申请一块大内存，再由  malloc() 完成再分配。

【mmap】

```c
#include <unistd.h>
#include <sys/mman.h>
/**
 * addr:   该内存区域的起始地址
 * length: 该内存区域的长度
 * prot:   该内存区域的访问权限
 * flags:  该内存区域的类型
 * fd:     文件描述符
 * offset: 文件内的偏移量
 */
void* mmap(void* addr, size_t length, int prot, int flags, int fd, off_t offset);
```

mmap的功能随之 prot、flags和fd这三个参数的不同，可以用于创建共享内存，可以创建磁盘文件映射区域，还可以用来申请堆内存。

- prot的值可以是以下四个常量的组合：
  - PROT_EXEC，表示这块内存区域有可执行权限，意味着这部分内存可以看成是代码段，它里面存储的往往是 CPU 可以执行的机器码；
  - PROT_READ，表示这块内存区域可读；
  - PROT_WRITE，表示这块内存区域可写；
  - PROT_NONE，表示这块内存区域的页面不能被访问；
- flags的值常量多（可以通过man mmap查看），以下是最重要的四种可取值常量：
  - MAP_SHARED，创建一个共享映射的区域，多个进程可以通过共享映射的方式，来共享同一个文件。这样一个进程对该文件的修改，其他进程也可以观察到，可以实现了数据的通讯；
  - MAP_PRIVATE，创建一个私有的映射区域，多个进程可以使用私有映射的方式，来映射同一个文件。但是，当一个进程对文件进行修改时，操作系统就会为它创建一个独立的副本，这样它对文件的修改，其他进程就看不到了，从而达到映射区域私有的目的；
  - MAP_ANONYMOUS，创建一个**匿名映射**，也就是没有关联文件。使用这个选项时，fd 参数必须为空。通常可以使用私有匿名映射来进行堆内存的分配。
  - MAP_FIXED，一般来说，addr 参数只是建议操作系统尽量以 addr 为起始地址进行内存映射，但如果操作系统判断 addr 作为起始地址不能满足长度或者权限要求时，就会另外再找其他适合的区域进行映射。如果 flags 的值取是 MAP_FIXED 的话，就不再把 addr 看成是建议了，而是将其视为强制要求。如果不能成功映射，就会返回空指针；
- fd的值只有两种类型：
  - 不为0，mmap映射的内存区域将会和文件关联；
  - 为0，没有对应的相关文件，此时就是匿名映射，flags 的取值必须为 MAP_ANONYMOUS；

![](https://static001.geekbang.org/resource/image/98/93/98fcb5aa607b8be9ffa037e9f7eea593.jpg?wh=2284x1285)
